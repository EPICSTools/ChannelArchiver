\section{Index Files}
An index file contain a list of all the channels in an archive, and
for each channel it contains information about the data blocks which
are available in the Data Files of an archive.

\noindent The archiver toolset uses index files for two slightly different
purposes:
\begin{enumerate}
\item Each ArchiveEngine creates an index for the data files
      that it writes.
      We refer to this combination of index and data files
      as a \INDEX{Sub-Archive}.
      If a sub archive contains data for a certain channel and time
      range, it will contain that data only once.
\item We can create a \INDEX{Master Index} that points to data
      in several sub archives.
      Several sub-archives might contain data for the same channel
      and time range. When we combine sub-archives into a master
      index, we can assign \INDEX{Sub-Archive Priorities} to
      determine what data is considered more important.
\end{enumerate}

\noindent Another important difference between sub-archive index files
and master index files lies in the fact that the sub-archive index
files only contain the relative path to their data files.
A sub-archive index and its data file can therefore be moved to a new
location.
The master index file contains the full path to its data files,
because different sub-archives can use the same data file names within
their sub-archive directory and we can only distinguish data files vy
their full path.
Once a master archive index has been created, the sub-archives must
therefore not be moved. If any of the sub-archives gets moved, the
master index needs to be recreated.

The channel names are maintained in a hash table and the
data block information is kept in an R*Tree structure.
An R*Tree is a balanced tree taylored for holding
multidimensional data like time ranges.
The leaves of the tree contain the data block
information (i.e.\ path to a data file and offset inside that data
file) and the time range that is covered by the data block. Parent
nodes reflect the time range covered by all their child nodes, up
until the root node which holds the total time range covered by all
the data blocks. Each node can be a list of sub-nodes. How many
sub-nodes there are per node is determined by a tunable parameter M.

\begin{figure}[htb]
\begin{center}
\InsertImage{width=0.6\textwidth}{rtree}
\end{center}
\caption{\label{fig:rtree}R*Tree Demo, refer to text.}
\end{figure}

Fig.~\ref{fig:rtree} demonstrates a tree that covers the total
time range from ``1'' to ``9'' (in the real world, these numbers would
be much bigger since they represent seconds since some ``Epoch'').
The letters C, D, ... represent data blocks. To handle a request for a
time range [3;6], we first determine if that range is covered by the tree
at all by checking the root's time range. Since that is the case,
we go down one level, check the subnodes, go down again etc.\ until
we end up at the data blocks.
Note that data block ``G'' is listed several times. The reason could
be that data block ``G'' in fact contains data from ``2'' to ``9''.
But since other data blocks with a higher priority have data in at least part
of that same time range and the leaves of the R*Tree must not overlap,
the data block G=[2;9] was partitioned into [2;3], [4;5] and [7;9].
The remaining time ranges like [3;4] happen to be covered by other
data blocks.

\subsection{Implementation Details}
The header of the index file contains the magic id number, the
parameter M of the R trees, and the start address of the hash table.

The hash table stores the "channel name table units" (CNTUs) which
contain the channel names and two pointers: one to the corresponding
AU list, the other to the corresponding R tree (as a reminder: each AU
stores only one channel).

The AU list is a double linked list, ordered by the start time of the
AUs. It stores (absolute) paths and offsets of the AUs, the start and
end times of the archived data and its priority. The path length is
variable.

The R tree consists of the root and a number of R tree entries.
An R tree root is virtually the header of an R tree. It stores the
entire interval of the archived data (i.e. oen that spans over all R
entries), the parameter "i" which determines the maximum number of
entries (i.e. the size of the R tree) before the reserved space is
full, the first free index inside the reserved space, the index of the
first entry on the highest level of the R tree, and- for performance-
the index of the last entry on the lowest level.

Since we don't delete AUs (see also "algorithms"), it is guaranteed
that before adding a new AU, all indices upto the one that is stored
inside the R tree as the "first free index" are occupied by the R
entries.

When the reserved space fills up, a twice as large space is allocated,
the parameter "i" is increased by 1, and the R tree is moved to
another address. So internally, instead of addresses indices are used
to establish links between the R entries.

An R entry can be of two types: an internal entry or a leaf. Both
types have some common features:

Common features: pointers to the index of the next entry (or -1 if
there is no next entry), to the previous entry and to the parent entry
(-1 means here highest level).

Leaf features: a -1 as an indication there are no children, a pointer
to the corresponding AU pointer list, and either the complete interval
of the key AU, or a part of its interval (and intervals of other AUs
in the AU pointer list, see "algorithms").

Internal entry features: a pointer to the child entry, the entire
interval of the child node (a 'node' is not to be confused with an
'entry'), and a -1 in place of a pointer to the AU pointer list.

An R node is a union of at least M and at most (2*M - 1) R entries on
each level. The R entries in one node have all the same parent
entry. The parameter M is important for balancing the R tree.

The AU pointers in the lists are ordered in accordance with the
following criteria:
\begin{itemize}
\item the priority of an AU
\item the "continuity" of an AU being the key, i.e. if the new AU is the
 key of the previous leaf, it is the key of this leaf, too; if the key
 AU of the previous leaf is the same as the key of the current leaf
 (before the insert), leave the key, and apply the next criteria
\item the end times of the AUs (so that the number of retrieved AUs is as
 small as possible)
\end{itemize}

Two more characteristica: The intervals of R entries on eachlevel do
 not intersect. A leaf points to a distinct AU pointer list, i.e. for
 each given interval, only one possible sequence of AUs is retrieved
 (according the criterias above).

To achieve this vital features, the intervals of the AUs might need to
be partitioned (see "alogithms").
