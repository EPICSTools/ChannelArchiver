\section{Index Files}
An index file contain a list of all the channels in an archive, and
for each channel it contains information about the data blocks which
are available in the Data Files of an archive.

\noindent The archiver toolset uses index files for two slightly different
purposes:
\begin{enumerate}
\item Each ArchiveEngine creates an index for the data files
      that it writes.
      We refer to this combination of index and data files
      as a \INDEX{Sub-Archive}.
      If a sub archive contains data for a certain channel and time
      range, it will contain that data only once.
\item We can create a \INDEX{Master Index} that points to data
      in several sub archives.
      Several sub-archives might contain data for the same channel
      and time range. When we combine sub-archives into a master
      index, we can assign \INDEX{Sub-Archive Priorities} to
      determine what data is considered more important.
\end{enumerate}

\noindent Another important difference between sub-archive index files
and master index files lies in the fact that the sub-archive index
files only contain the relative path names to their data files.
A sub-archive index and its data file can therefore be moved to a new
location. As long as the index file and its data files remain
in one directory, the location of that directory does not matter.

The master index file on the other hand contains the full path to its
data files, because different sub-archives can use the same data file
names within their sub-archive directory and we can only distinguish
data files by their full path.  Once a master archive index has been
created, the sub-archives must therefore not be moved. If any of the
sub-archives gets moved, the master index needs to be recreated.

The channel names are maintained in a hash table and the
data block information is kept in a modified RTree structure.
An RTree \cite{guttman84} is a balanced tree taylored for holding
multidimensional data like rectangles, allowing lookup of
rectangles via points that fall inside rectangles.
Sergei Chevtsov extended this concept to handle time ranges.

Each node in an RTree has several records. How many records there are
per node is determine by a tunable parameter $M$.
The records in the leave nodes of the tree point to data block
information (i.e.\ path to a data file and offset inside that data
file) and the time range that is covered by the data block.
The records do not overlap, i.e.\ no two records will cover the same
time range, and the records are sorted in time.
Since the actual data blocks might overlap for a master index, more
than one non-overlapping record might refer to the same data block.
Records in parent nodes reflect the time range covered by all their
child node records, up to the root node records which hold the total
time range covered by all the data blocks.

\begin{figure}[htb]
\begin{center}
\InsertImage{width=0.6\textwidth}{rtree}
\end{center}
\caption{\label{fig:rtree}RTree Demo, refer to text.}
\end{figure}

THIS NEEDS TO BE ADJUSTED:

Fig.~\ref{fig:rtree} demonstrates a tree that covers the total
time range from ``1'' to ``9'' (in the real world, these numbers would
be much bigger since they represent seconds since some ``Epoch'').
The letters C, D, ... represent data blocks. To handle a request for a
time range [3;6], we first determine if that range is covered by the tree
at all by checking the root's time range. Since that is the case,
we go down one level, check the subnodes, go down again etc.\ until
we end up at the data blocks.
Note that data block ``G'' is listed several times. The reason could
be that data block ``G'' in fact contains data from ``2'' to ``9''.
But since other data blocks with a higher priority have data in at least part
of that same time range and the leaves of the RTree must not overlap,
the data block G=[2;9] was partitioned into [2;3], [4;5] and [7;9].
The remaining time ranges like [3;4] happen to be covered by other
data blocks.

\subsection{Implementation Details}

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{ll}
     Offset  & Content \\
     \hline
     0x0000  & 'CAI1' \\
     0x0004  & NameHash anchor: start (0x30), size N \\
     0x000C  & FileAllocator used list: size, start (0x24), end \\
     0x0018  & FileAllocator free list: size, start, end \\
     0x0024  & FileAllocator header: size, prev(0), next(??) \\
     0x0030  & Hash Table Entry 0: \\
             & Pointer to first entry for this hash value \\
     0x0034  & Hash Table Entry 1:  \\
     ...     & ... \\
     ??????  & Hash Table Entry N-1:  \\
     ...     & ... \\
     ??????  & FileAllocator header: size, prev(0), next(??) \\
     ??????  & Hash Entry: \\
             & next, RTree pointer, channel name \\
     ...     & ... \\  
     ??????  & FileAllocator header: size, prev(0), next(??) \\
     ??????  & RTree: pointer to root node, M value \\
     ...     & ... \\  
    \end{tabular}
    \caption{Index file: Example layout.}
    \label{tab:indexfile}
  \end{center}
\end{table}

\noindent Table~\ref{tab:indexfile} shows the basic layout of an index file.
The header of the index file contains a 4-ASCII character magic id
like 'CAI1' for ``Channel Archiver Index Type 1'',
and the hash table anchor.
Those 12 bytes constitute ``reserved space'' for the FileAllocator
class. What follows is start- and end pointers for the FileAllocator's
list of allocated and available items, because the remaining file space is
handled by the FileAllocator class.
The first allocated region is the NameHash, so it's start location
would be known. Each hash table entry points to the start of channel
entries that hashed to the repective value, and each channel entry
contains the anchor for its RTree. Like every file block after the
``reserved space'', the hash table and each channel entry are preceeded
by a FileAllcator header.

An RTree entry consists of the pointer to the root node and a number
of records per node $M$. The RTree nodes are interlinked as shown in
the example in Fig.~\ref{fig:rtree}, where each node and data block is
allocated from the FileAllocator class. For details of how the nodes
and data blocks are written to the disk you will have to use the force
and read the source.
