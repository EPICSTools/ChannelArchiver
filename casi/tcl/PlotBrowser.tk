#!/bin/sh
# -*- tcl -*- \
	exec atac $0 ${1+"$@"}


# --------------------------------------------------------
# $Id$
#
# Please refer to NOTICE.txt,
# included as part of this distribution,
# for legal information.
#
# Kay-Uwe Kasemir, kasemir@lanl.gov
# --------------------------------------------------------


#######################################################################
# Demo of plotting from archive with BLT
#######################################################################

source casiTools.tcl
source casiGraph.tk

# Globals --------------------------------------------
# graph:
#	BLT graph ID
# startStamp, endStamp:
#	visible time range
# samples:
#	Number of samples shown in plot
# archive:
#	atac archive ID
# channelName(0), channelName(1), ...:
#	Channel names.
#   indices 0, 1, ... are also used as keys for atacGraph routines

proc usage {} {
	global argv0
	puts "USAGE: $argv0 archive channelName ?channelName? ..."

	exit 1
}      

set showArchiveName 0
set samples 0

#################################
# Parse args
#
set argc [ llength $argv ]
if { $argc < 2 } { usage }

set archiveName [ lindex $argv 0 ]
set key 0
foreach name [ lrange $argv 1 end ] {
	set channelName($key) $name
	incr key
}

set archive [ archive ]
if { ! [ $archive open $archiveName ] } {
    puts "Cannot open archive $archiveName"
    exit 1
}


#################################
# GUI
#
option add *background #AEC9D2

set height 30

if { $showArchiveName } {
    frame .archivename
    label .archivename.lbl -text "Archive:" -width 10
    entry .archivename.entry -textvariable archiveName
    pack .archivename.lbl -side left
    pack .archivename.entry -side right -expand yes -fill x
    pack .archivename -expand yes -fill x -side bottom
}

frame .start
label .start.lbl -text "Start:" -width 10
entry .start.entry -textvariable startStamp -width 30
pack .start.lbl -side left
pack .start.entry  -side left

frame .end
label .end.lbl -text "End:" -width 10
entry .end.entry -textvariable endStamp -width 30
pack .end.lbl -side left
pack .end.entry  -side left

frame .samples
label .samples.lbl -text "Samples:" -width 10
entry .samples.entry -textvariable samples -width 30
pack .samples.lbl -side left
pack .samples.entry  -side left

frame .buttons
button .buttons.fastback -command "backward 0.9" -text "<<<"
button .buttons.backward -command "backward 0.2" -text "<"
button .buttons.zoomin   -command "zoomIn"       -text "In"
button .buttons.zoomout  -command "zoomOut"      -text "Out"
button .buttons.forward  -command "forward 0.2"  -text ">"
button .buttons.fastfor  -command "forward 0.9"  -text ">>>"
button .buttons.exit -command "exit" -text "Exit"
pack .buttons.fastback -side left -padx 5
pack .buttons.backward -side left -padx 5
pack .buttons.zoomin   -side left -padx 5
pack .buttons.zoomout  -side left -padx 5
pack .buttons.forward  -side left -padx 5
pack .buttons.fastfor  -side left -padx 5
pack .buttons.exit     -side right -padx 0

pack .buttons -fill x -side bottom
pack .samples -fill x -side bottom
pack .end -fill x -side bottom
pack .start -fill x -side bottom
createCasiGraph .g
set graph .g
pack .g -expand yes -fill both -side top


update

#########################################################

#  Get the last count samples for channel $channelName($key)
proc getLastSamples { key count } {
    global graph archive channelName startStamp endStamp

    set channel [ channel ]
    set value   [ value ]
    $archive findChannelByName $channelName($key) $channel
    $channel getLastValue $value
    initGraphData $key $channelName($key)
    while { $count > 0  &&  [ $value valid ] } {
	prependGraphData  $key $value
	$value prev
	incr count -1
    }
    rename $value {}
    rename $channel {}
    addToGraph $key $graph

    set startStamp [ secs2stamp [ getGraphDataStartSecs $key ] ]
    set endStamp   [ secs2stamp [ getGraphDataEndSecs   $key ] ]
}

# get values from start to end
proc getKeyData { key start end } {
    global samples graph archive channelName

    # read one value before start and after end
    # in order to "fill" the plot to the outsides
    set channel [ channel ]
    set value   [ value ]
    $archive findChannelByName $channelName($key) $channel
    $channel getValueBeforeTime $start $value
    if { ! [ $value valid ] } {
	$channel getValueAfterTime $start $value
    }
    initGraphData $key $channelName($key)
    while { [ $value valid ] } {
	addGraphData $key $value
	if { [ $value time ] > $end } break
	$value next
    }
    rename $value {}
    rename $channel {}
    addToGraph $key $graph
    incr samples [ getGraphDataCount $key ]
}

# get values from start to end
proc getData { start end } {
    global samples graph channelName
    
    set samples 0
    foreach key [ array names channelName ] {
	getKeyData $key $start $end
	update
    }
    $graph axis configure x -min [ stamp2secs $start ] -max [ stamp2secs $end ]
}

# Move start and end of time range
# by portion of visible range
proc moveRange { startPortion endPortion } {
    global startStamp endStamp
    
    # determine on-graph time range
    set s0 [ stamp2secs $startStamp ]
    set s1 [ stamp2secs $endStamp ]
    set delta [ expr $s1 - $s0 ]
    
    # find new start...end
    set startSecs  [ expr $s0 + $startPortion * $delta ] 
    set endSecs    [ expr $s1 + $endPortion   * $delta ] 
    set startStamp [ secs2stamp $startSecs ]
    set endStamp   [ secs2stamp $endSecs   ]
    update
    
    getData $startStamp $endStamp
}

proc forward { portion } {
    busy hold .
    update
    moveRange $portion $portion
    busy release .
    update
}

proc backward { portion } {
    busy hold .
    update
    moveRange -$portion -$portion
    busy release .
    update
}

proc zoomIn {} {
    busy hold .
    update
    moveRange 0.2 -0.2
    busy release .
    update
}

proc zoomOut {} {
    busy hold .
    update
    moveRange -0.8 0.8
    busy release .
    update
}

#########################################################
# Initialize

busy hold .
update

# use first channel to determine time range
# by fetching "count" samples
set key 0
set count 200
getLastSamples $key $count

# Fill this time range for remaining channels
foreach key [ lrange [ array names channelName ] 1 end ] {
    getKeyData $key $startStamp $endStamp
}

busy release .

update

# saveGraph PS .g "snapshot.ps"

