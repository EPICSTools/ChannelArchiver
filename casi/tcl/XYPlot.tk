
source casiTools.tcl
package require BLT
namespace import blt::*

proc usage {} {
	global argv0
	puts "USAGE: $argv0 archive xChannelName yChannelName \[ time \]"
	puts "       time as \"YYYY/MM/DD hh:mm:ss\" in 24h format"
	exit 1
}

#################################
# Parse args
#
set argc [ llength $argv ]
if { $argc < 3 } { usage }

set archiveName  [ lindex $argv 0 ]
set xChannelName [ lindex $argv 1 ]
set yChannelName [ lindex $argv 2 ]
if { $argc > 3 } {
	set time     [ lindex $argv 3 ]
} else {
	set time	0
}

#########################################################################
# Globals:
set archiveId	0
set xChannelId	0
set yChannelId	0
set xValueId	0
set xStamp      0
set yStamp      0
set gap         0
# yValueId is temporary

#########################################################################
# GUI
#
option add *background #AEC9D2 

set textWidth 10
frame .archivename
label .archivename.lbl -text "Archive:" -width $textWidth
entry .archivename.entry -textvariable archiveName
pack .archivename.lbl -side left
pack .archivename.entry -side right -expand yes -fill x

frame .xchannelname
label .xchannelname.lbl -text "X Channel:" -width $textWidth
entry .xchannelname.entry -textvariable xChannelName
button .xchannelname.info -text "?" -command { createChannelInfo $archiveName $xChannelName }
pack .xchannelname.lbl -side left
pack .xchannelname.entry -side left -expand yes -fill x
pack .xchannelname.info -side right

frame .ychannelname
label .ychannelname.lbl -text "Y Channel:" -width $textWidth
entry .ychannelname.entry -textvariable yChannelName
button .ychannelname.info -text "?" -command { createChannelInfo $archiveName $yChannelName }
pack .ychannelname.lbl -side left
pack .ychannelname.entry -side left -expand yes -fill x
pack .ychannelname.info -side right

frame .start
label .start.lbl -text "Time:" -width $textWidth
entry .start.entry -textvariable time
pack .start.lbl -side left
pack .start.entry -side right -expand yes -fill x

set xygraph [ graph .xy -title "X/Y Plot" ]
vector xData yData
$xygraph element create data -xdata xData -ydata yData -symbol {} -label {}

frame .times
label .times.xlbl     -text "X Time:" -width $textWidth
entry .times.xentry   -textvariable xStamp -width 40
label .times.ylbl     -text "Y Time:" -width $textWidth
entry .times.yentry   -textvariable yStamp -width 40
label .times.gaplbl   -text "Gap:" -width $textWidth
entry .times.gapentry -textvariable gap

grid .times.xlbl .times.xentry .times.gaplbl .times.gapentry -row 0
grid .times.ylbl .times.yentry -row 1

frame .buttons
button .buttons.restart -command "restart" -text "Restart"
button .buttons.backward -command "backward" -text "<<<"
button .buttons.forward  -command "forward" -text ">>>"
button .buttons.exit -command "exit" -text "Exit"

pack .buttons.restart  -side left  -padx 0
pack .buttons.backward -side left  -padx 10
pack .buttons.forward  -side left  -padx 10
pack .buttons.exit     -side right -padx 0

pack .archivename -side top -fill x
pack .xchannelname -side top  -fill x
pack .ychannelname -side top  -fill x
pack .start -side top -fill x
pack .buttons -side bottom -fill x
pack .times -side bottom -fill x
pack $xygraph -side top -expand yes -fill both

#########################################################################
#

proc openArchive {} {
    global archiveId xChannelId yChannelId archiveName xChannelName yChannelName xValueId yValueId

    set archiveId [ archive ]
    set xChannelId [ channel ]
    set yChannelId [ channel ]
    set xValueId [ value ]
    set yValueId [ value ]
    if { ! [ $archiveId open $archiveName ] } {
	error "Cannot open $archiveName"
    }
    if { ! [ $archiveId findChannelByName $xChannelName $xChannelId ] } {
	error "Cannot find channel $xChannelName"
    }
    if { ! [ $archiveId findChannelByName $yChannelName $yChannelId ] } {
	error "Cannot find channel $yChannelName"
    }
}

# Note: Called in restart when all Ids are invalid!
proc closeArchive {} {
    global archiveId xChannelId yChannelId xValueId yValueId
    
    catch { rename $xValueId {} }
    catch { rename $yValueId {} }
    catch { rename $xChannelId {} }
    catch { rename $yChannelId {} }
    catch { rename $archiveId {} }
}

#########################################################################
# Look for x/y pair close to "when".
# Set timeVar, xVar, yVar to values found.
#
# Result: >=0 Difference in seconds between the original timestamps found
#          <0 Nothing found

proc getXY { when timeVar xVar yVar } {
    upvar $xVar x
    upvar $yVar y
    upvar $timeVar time
    global xChannelId yChannelId xValueId yValueId xStamp yStamp
    
    if { $when == 0 } { set when [ $xChannelId getFirstTime ] }
    
    # set xValueId to something close to $time
    # (maybe it's already there)
    if { ![ $xValueId valid ]  ||  [ $xValueId time ] != $when } {
	$xChannelId getValueNearTime $when $xValueId
    }
    if { ! [ $xValueId valid ] } { return -1 }

    set xStamp [ $xValueId time ]

    if { ! [ $yChannelId getValueNearTime $xStamp $yValueId ] } { return -1 }
	

    set yStamp [ $yValueId time ]
    set x ""
    set y ""
    for { set i 0 } { $i< [ $xValueId count ] } { incr i } {
	lappend x [ $xValueId getidx $i ]
	lappend y [ $yValueId getidx $i ]
    }

    set gap [ expr [ stamp2secs $xStamp ] - [ stamp2secs $yStamp ] ]
    set time [ secs2stamp [ expr [ stamp2secs $yStamp ] + $gap ] ]

    return [ expr abs($gap) ]
}

#########################################################################
# Button commands
#

proc backward {} {
    global xValueId time gap

    if { ! [ $xValueId valid ] } { return }

    $xValueId prev 
    if { ! [ $xValueId valid  ] } {
	$xValueIdnext 
	return
    }
    
    set gap [ getXY [ $xValueId time ] time x y ]
    if { $gap >= 0 } {
	xData set $x
	yData set $y
    }
}

proc forward {} {
    global xValueId time gap

    if { ! [ $xValueId valid  ] } { return }
    
    $xValueId next
    if { ! [$xValueId valid ] } {
	$xValueId prev 
	return
    }
    
    set gap [ getXY [ $xValueId time ] time x y ]
    if { $gap >= 0 } {
	xData set $x
	yData set $y
    }
}

proc restart {} {
    global time gap
    
    closeArchive
    openArchive
    set gap [ getXY $time time x y ]
    if { $gap >= 0 } {
	xData set $x
	yData set $y
    }
}

#########################################################################
#
restart

