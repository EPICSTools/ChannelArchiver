// Export/main.cpp

// Base
#include <epicsVersion.h>
// Tools
#include <AutoPtr.h>
#include <BinaryTree.h>
#include <RegularExpression.h>
#include <epicsTimeHelper.h>
#include <ArgParser.h>
// Storage
#include <SpreadsheetReader.h>
#include <PlotReader.h>

bool verbose;

// "visitor" for BinaryTree of channel names
static void add_name2vector(const stdString &name, void *arg)
{
    stdVector<stdString> *names = (stdVector<stdString> *)arg;
    if (verbose)
        printf("%s\n", name.c_str());
    names->push_back(name);
}

void get_names_for_pattern(IndexFile &index,
                           stdVector<stdString> &names,
                           const stdString &pattern)
{
    if (verbose)
        printf("Expanding pattern '%s'\n", pattern.c_str());
    RegularExpression *regex = 0;
    if (pattern.length() > 0)
    {
        regex = RegularExpression::reference(pattern.c_str());
        if (!regex)
        {
            fprintf(stderr, "Cannot allocate regular expression\n");
            return;
        }
    }
    IndexFile::NameIterator name_iter;
    if (!index.getFirstChannel(name_iter))
        return; // No names
    // Put all names in binary tree
    BinaryTree<stdString> channels;
    do
    {
        if (regex && !regex->doesMatch(name_iter.getName()))
            continue; // skip what doesn't match regex
        channels.add(name_iter.getName());
    }
    while (index.getNextChannel(name_iter));
    if (regex)
        regex->release();
    // Sorted dump of names
    channels.traverse(add_name2vector, (void *)&names);
}

bool list_channels(IndexFile &index, stdVector<stdString> names,
                   bool show_info)
{
    stdVector<stdString>::iterator name;
    epicsTime start, end;
    stdString s, e;
    for (name = names.begin(); name != names.end(); ++name)
    {
        if (show_info)
        {
            AutoPtr<RTree> tree(index.getTree((*name)));
            if (tree)
            {
                tree->getInterval(start, end);
                printf("%s\t%s\t%s\n", (*name).c_str(),
                       epicsTimeTxt(start, s), epicsTimeTxt(end, e));
            }
        }
        else
            printf("%s\n", (*name).c_str());
    }
    return true;
}

bool dump_gnuplot(IndexFile &index,
                  stdVector<stdString> names,
                  epicsTime *start, epicsTime *end,
                  double interpolate,
                  stdString output_name,
                  bool image)
{
    stdVector<stdString> units;
    size_t i;
    stdString time, stat, val;
    const RawValue::Data *value;
    
    FILE *f = fopen(output_name.c_str(), "wt");
    if (! f)
    {
        fprintf(stderr, "Cannot open %s\n",
                output_name.c_str());
        return false;
    }
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    for (i=0; i<names.size(); ++i)
    {
        fprintf(f, "# Channel '%s'\n", names[i].c_str());
        PlotReader *reader = new PlotReader(index, interpolate);
        value = reader->find(names[i], start);
        if (value)
            units.push_back(reader->getInfo().getUnits());
        else
            units.push_back("-no data-");
        while (value)
        {
            if (end && RawValue::getTime(value) >= *end)
                break;
            if (RawValue::isInfo(value))
                fprintf(f, "\n# "); // GNUPlot line break
            fprintf(f, "%s", epicsTimeTxt(RawValue::getTime(value), time));
            RawValue::getStatus(value, stat);
            if (RawValue::isInfo(value))
                val = "#N/A";
            else
                RawValue::getValueString(
                    val, reader->getType(), reader->getCount(),
                    value, &reader->getInfo());
            fprintf(f, "\t%s\t%s\n", val.c_str(), stat.c_str());
            value = reader->next();
        }
        fprintf(f, "\n\n"); // GNUPlot index separator
        delete reader;
    }
    fclose(f);
    // Generate command file for GNUPlot
    stdString cmd_name = output_name;
    cmd_name += ".plt";
    if (!(f = fopen(cmd_name.c_str(), "wt")))
        fprintf(stderr, "Cannot create %s\n",
                cmd_name.c_str());
    fprintf(f, "# GNUPlot command file for data in\n");
    fprintf(f, "# %s\n", output_name.c_str());
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    fprintf(f, "\n");
    fprintf(f, "set data style steps\n");   
    fprintf(f, "set timefmt \"%%m/%%d/%%Y %%H:%%M:%%S\"\n");	
    fprintf(f, "set xdata time\n");
    fprintf(f, "set xlabel \"Time\"\n");	
    fprintf(f, "set format x \"%%m/%%d/%%Y\\n%%H:%%M:%%S\"\n");
    fprintf(f, "set ylabel \"Data\"\n");
    fprintf(f, "set grid\n");
    if (image)
    {
        fprintf(f, "set terminal png small color "
                "xfffcce x000040 xd1cfad\n");
        fprintf(f, "set output '%s.png'\n",
                output_name.c_str());
    }
    fprintf(f, "plot '%s' index 0 using 1:3 title '%s [%s]'",
            output_name.c_str(),
            names[0].c_str(), units[0].c_str());
    for (i=1; i<names.size(); ++i)
        fprintf(f, ", '%s' index %d using 1:3 title '%s [%s]'",
                output_name.c_str(), i,
                names[i].c_str(), units[i].c_str());
    fprintf(f, "\n");
    fclose(f);
    return true;
}

bool dump_spreadsheet(IndexFile &index,
                      stdVector<stdString> names,
                      epicsTime *start, epicsTime *end,
                      double interpolate,
                      bool status_text,
                      stdString output_name)
{
    SpreadsheetReader sheet(index, interpolate);
    bool ok = sheet.find(names, start);
    size_t i;
    stdString time, stat, val;
    const RawValue::Data *value;
    FILE *f = stdout;
    if (output_name.length() > 0)
        f = fopen(output_name.c_str(), "wt");
    if (! f)
    {
        fprintf(stderr, "Cannot open %s\n",
                output_name.c_str());
        return false;
    }
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    fprintf(f, "\n");
    fprintf(f, "# Time                       ");
    for (i=0; i<sheet.getNum(); ++i)
    {
        fprintf(f, "\t%s [%s]", sheet.getName(i).c_str(),
               sheet.getCtrlInfo(i).getUnits());
        if (status_text)
            fprintf(f, "\t");
    }
    fprintf(f, "\n");
    while (ok)
    {
        if (end && sheet.getTime() >= *end)
            break;
        fprintf(f, "%s", epicsTimeTxt(sheet.getTime(), time));
        for (i=0; i<sheet.getNum(); ++i)
        {
            value = sheet.getValue(i);
            if (value)
            {
                RawValue::getStatus(value, stat);
                if (RawValue::isInfo(value))
                {
                    fprintf(f, "\t#N/A");
                    if (status_text)
                        fprintf(f, "\t%s", stat.c_str());
                }
                else
                {
                    RawValue::getValueString(
                        val, sheet.getType(i), sheet.getCount(i),
                        value, &sheet.getCtrlInfo(i));
                    fprintf(f, "\t%s", val.c_str());
                    if (status_text)
                        fprintf(f, "\t%s", stat.c_str());
                }
            }
            else
            {
                fprintf(f, "\t#N/A");
                if (status_text)
                    fprintf(f, "\t");
            }
        }
        fprintf(f, "\n");
        ok = sheet.next();
    }
    if (f != stdout)
        fclose(f);
    return true;
}

int main(int argc, const char *argv[])
{
    int result = 0;
    initEpicsTimeHelper();
    CmdArgParser parser(argc, argv);
    parser.setHeader("Archive Export version " ARCH_VERSION_TXT ", "
                     EPICS_VERSION_STRING
                     ", built " __DATE__ ", " __TIME__ "\n\n");
    parser.setArgumentsInfo("<index file> {channel}");
    CmdArgFlag   be_verbose (parser, "verbose", "Verbose mode");
    CmdArgFlag   do_list    (parser, "list", "List all channels");
    CmdArgFlag   do_info    (parser, "info", "Time-range info on channels");
    CmdArgString start_time (parser, "start", "<time>",
                             "Format: \"mm/dd/yyyy[ hh:mm:ss[.nano-secs]]\"");
    CmdArgString end_time   (parser, "end", "<time>", "(exclusive)");
    CmdArgFlag   status_text(parser, "text",
                             "Include text column for status/severity");
    CmdArgString pattern    (parser, "match", "<reg. exp.>",
                             "Channel name pattern");
    CmdArgDouble interpol   (parser,
                             "interpolate", "<seconds>", "interpolate values");
    CmdArgString output     (parser,
                             "output", "<file>", "output to file");
    CmdArgFlag   GNUPlot    (parser,
                             "gnuplot", "generate GNUPlot command file");
    CmdArgFlag   image      (parser,
                             "Gnuplot", "generate GNUPlot output for Image");
#if 0
    CmdArgInt    reduce     (parser,
                             "reduce", "<# of buckets>", "reduce data to # buckets");
    CmdArgFlag   pipe       (parser,
                             "pipe", "run GNUPlot via pipe");
    CmdArgFlag   MLSheet    (parser,
                             "MLSheet", "generate spreadsheet for Matlab");
    CmdArgFlag   Matlab     (parser,
                             "Matlab", "generate Matlab command-file output");
#endif
    if (! parser.parse())
        return -1;
    if (parser.getArguments().size() < 1)
    {
        parser.usage();
        return -1;
    }
    verbose = be_verbose;

    // Start/end time
    epicsTime *start = 0, *end = 0;
    stdString txt;
	if (start_time.get().length() > 0)
    {
        start = new epicsTime;
        string2epicsTime(start_time.get(), *start);
        if (verbose)
            printf("Using start time %s\n", epicsTimeTxt(*start, txt));
    }
	if (end_time.get().length() > 0)
    {
        end = new epicsTime();
        string2epicsTime(end_time.get(), *end);
        if (verbose)
            printf("Using end time   %s\n", epicsTimeTxt(*end, txt));
    }
    // Index name
    stdString index_name = parser.getArgument(0);
    // Channel names
    stdVector<stdString> names;
    if (parser.getArguments().size() > 1)
    {
        if (! pattern.get().empty())
        {
            fputs("Pattern from '-m' switch is ignored\n"
                  "since a list of channels was also provided.\n", stderr);
        }
        // first argument was directory file name, skip that:
        for (size_t i=1; i<parser.getArguments().size(); ++i)
            names.push_back(parser.getArgument(i));
    }
    if ((GNUPlot || image) && output.get().length() == 0)
    {

        fprintf(stderr, "The -gnuplot/Gnuplot options require "
                "an -output file\n");
        return -1;    
    }
    // Open index
    IndexFile index(50);
    if (!index.open(index_name.c_str()))
    {
        fprintf(stderr, "Cannot open index '%s'\n",
                index_name.c_str());
        return -1;
    }
    if (verbose)
        printf("Opened index '%s'\n", index_name.c_str());    
    if (names.size() == 0 &&
        (do_list  ||  pattern.get().length() > 0))
        get_names_for_pattern(index, names, pattern);
    if (do_info)
        result = list_channels(index, names, true);
    else if (do_list)
        result = list_channels(index, names, false);
    else if (names.size() > 0)
    {
        if (GNUPlot)
            result = dump_gnuplot(index, names, start, end,
                                  interpol, output, image) ? 0 : -1;
        else
            result = dump_spreadsheet(index, names, start, end,
                                      interpol, status_text,
                                      output) ? 0 : -1;
    }
    index.close();
 
    return result;
}

